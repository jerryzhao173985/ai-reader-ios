{
  "memories": [
    {
      "type": "preference",
      "content": "Build/test on physical iPhone 15 Pro Max via WiFi (Device ID: 00008130-001659842E43001C). User prefers fundamentally correct, complete code that addresses root causes - not minimal changes or overkill complexity. OVERKILL AVOIDANCE: User explicitly stated 'I NEVER want unnecessary and not OVERKILL.' Classify fixes as: (1) ESSENTIAL - actual bug fix, (2) OPTIMIZATION - measurable improvement, (3) STYLISTIC - code preference. User only wants category 1 implemented by default. Defensive correctness valued over brevity when it aids maintainer understanding. User values first-principles thinking, careful verification before committing, and 'fresh eyes' review of all changes. Smooth reading UX critical: no flicker, no scroll jumps, no selection loss. For prompt formatting: use - symbols for lists, avoid special symbols like checkmarks or X marks. SIMPLICITY VALUED: User questions added infrastructure - prefer minimal storage that achieves the goal. CODE CLARITY: Explicit reset/cleanup at each exit point preferred over defer patterns. TRUST USER TESTING: When user reports behavior doesn't match analysis, re-verify against actual code before insisting on bug. NEVER REVERT USER WORK: User makes their own fixes - never blindly remove/revert user's changes. Always diff carefully to distinguish user's edits from Claude's. VERIFY BEFORE FIXING: Before proposing a bug fix, verify the bug actually exists in current code. A previously reported issue may already be solved by other changes. AVOID TRIAL-AND-ERROR: Don't implement speculative fixes for edge cases that virtually never happen (e.g., 100ms race windows). Propose and explain first, only implement if user agrees it's necessary. Reverting overengineered changes wastes time. PRE-COMMIT REVIEW: Always check BOTH staged (git diff --cached) AND unstaged (git diff) changes - missing staged changes caused missed bugs in past sessions. CONSISTENCY CHECK: When proposing N fixes, implement ALL N. Don't silently drop one during implementation — user will catch it. If dropping one, explain why explicitly. THOROUGH BEFORE EDITING: User wants full codebase investigation and verification BEFORE any edits. Rejected premature edits in favor of deeper analysis. Always trace exact code paths line-by-line. FRESH EYES REVIEW: After editing, re-read all changed files and run git diff to catch unintended modifications (e.g., Edit tool introducing extra lines). Verify committed vs current state.",
      "added_at": "2026-02-11T06:10:00.000000"
    },
    {
      "type": "completed_feature",
      "content": "AIReaderApp: iOS EPUB reader with SwiftUI, SwiftData, WKWebView. Features: Library with book context menu (Highlights/Archive), TOC, reading progress, text highlights with AI analysis (fact-check, discussion, key points, argument map, counterpoints, custom questions, comments), inline markers [1][2][3], delete highlight + undo, delete individual analysis (X button), haptic feedback, brain icon chapter highlights list, cross-chapter analysis persistence, analysis count badges, personal notes on highlights with search-includes-notes toggle. Archive Books System: Soft delete pattern with isArchived flag - books hidden from library but fully preserved with all highlights/analyses; restore via Settings > Archived Books (swipe right); permanent delete with confirmation dialog (swipe left). HighlightsView: accessible via Library long-press, exports (Markdown/JSON/Clipboard), in-place analysis expansion via HighlightDetailSheet, search filter includes notes (configurable). Comment feature: user notes without AI call, follow-ups work normally. HighlightAnalysisManager enables standalone analysis ops outside reader context (NOTE: deleteAnalysis() defined but currently has no caller from any view - dead code). AI: Dual-API support - GPT-5.2 (Responses API with reasoning effort + web_search tool) and GPT-4o (Chat Completions API) with auto-fallback. Model/webSearch tracking per analysis. No-flash highlight creation via JS injection. GitHub: jerryzhao173985/ai-reader-ios",
      "added_at": "2026-02-03T13:00:00.000000"
    },
    {
      "type": "technical",
      "content": "Architecture: book.highlights = ALL (book-scoped), currentChapterHighlights = filtered for chapter. AIAnalysisModel.prompt/response = initial Q&A; thread.turns = follow-ups. For comments: prompt = user's text, response = '' (empty). WKWebView: JS injection for marker/color updates (not loadHTMLString). Dual hash tracking (baseContentHash, styledContentHash). Selection preservation: defer marker AND colorHex updates when hasActiveTextSelection=true to pendingMarkerUpdatesQueue. Call clearSelection() after creating highlights. ChapterContentView state: 3-field tuple (highlightId, colorHex, analysisCount) for dedup. Two analysis viewing contexts: (1) AnalysisPanelView in reader (sheet), (2) HighlightDetailSheet in HighlightsView. STRUCTURAL DIFFERENCE: Library's streamingAnalysisView unconditionally renders currentQuestion; Reader's new-analysis streaming path does NOT render customQuestion (it's gated behind selectedAnalysis in analysisConversationView). This means stale question state that's invisible in Reader causes wrong display in Library. GATE ARCHITECTURE: Reader poll loops use TWO gates (selectedHighlight?.id == highlightId AND highlightToJobMap[highlightId] == jobId). Library HighlightAnalysisManager uses ONE gate (activeJobId == jobId, private). Reader X button clears selectedHighlight (Gate 1) so background jobs can't reach UI. Library needs returnToAnalysisList() method to clear activeJobId. AI API: GPT-5.2 uses /v1/responses with input+max_output_tokens+reasoning.effort+tools[web_search]; GPT-4o uses /v1/chat/completions. AIConfiguration cached at book open; settings accessed only from Library. SwiftData migration: New required properties need PROPERTY-level defaults for lightweight migration (e.g., var isArchived: Bool = false). JS listener deduplication: Use dataset.clickAttached guard to prevent duplicate event handlers. SwiftUI apps use @main App struct, NOT SceneDelegate - remove UISceneConfigurations from Info.plist if present. SwiftData error handling: For deletions use rollback() on failure (pending deletion is 'time bomb' committed by ANY later save). For property changes use manual revert (e.g., book.isArchived = false). Capture let bookId = book.id BEFORE delete() for defensive access. Database-first deletion order: delete from DB, save, THEN delete files. ScrollView offset: SwiftUI ScrollView maintains offset in POINTS (not percentage) - offset persists when content changes.",
      "added_at": "2026-02-10T23:00:00.000000"
    },
    {
      "type": "technical",
      "content": "Swift 6.2 Concurrency (iOS 26+): Three-layer job tracking: (1) UI layer: highlightToJobMap - latest job for streaming, (2) Ownership layer: highlightToJobIds - all jobs per highlight, (3) Cancellation layer: cancelledJobs Set. Polling uses two-layer cancellation: cancelledJobs.contains(jobId) && !Task.isCancelled (defense-in-depth). cleanupJob() handles all layers via defer. AsyncThrowingStream pattern: capture Task in variable, add onTermination handler to cancel task. CRITICAL: Task.isCancelled checks needed in ALL streaming loops INCLUDING fallback loops - unstructured Tasks do NOT propagate cancellation to inner Tasks (only async let and TaskGroup do). DEINIT: Use `isolated deinit` (SE-0371) for @MainActor classes - NOT MainActor.assumeIsolated. AIService.deinit calls session.invalidateAndCancel() (thread-safe, no isolation needed). SENDABLE: Explicit conformance on AIConfiguration, AIError, StreamEvent, NonStreamingResult, FollowUpInputMode, and all enums. AIError.networkError uses String (not Error) for Sendable compliance. Tasks created from @MainActor classes inherit isolation - no MainActor.run needed. DispatchQueue.main.async → Task { @MainActor in }. [weak self] RULES: Required for Tasks with delays in NSObject/Coordinator classes; NOT applicable to SwiftUI structs (value types) or immediate Tasks. DEBOUNCE PATTERN: Cancel-and-replace (task?.cancel(); task = Task { try await Task.sleep(for:); doWork() }). Duration API preferred (.milliseconds, .seconds) over nanoseconds.",
      "added_at": "2026-01-31T17:15:00.000000"
    },
    {
      "type": "decision",
      "content": "State & UX Patterns: (1) Atomic State Transitions: Update all related state variables together. (2) State Symmetry: All deselection/deletion/mode-change paths clear full state set. Reader X button clears 7 fields (AnalysisPanelView:160-169); Library Back button uses returnToAnalysisList() method. (3) Race Condition Guards: highlightToJobMap tracks ONE active job per highlight; isActiveJob guard prevents non-active job completions from resetting UI state. (4) Operation Symmetry: saveAnalysis(), selectAnalysis(), deleteAnalysis() all update colorHex and trigger pendingMarkerUpdate. (5) HighlightsView: In-place expansion preferred over reader navigation. (6) Job Isolation Pattern: prepareForNewCustomQuestion() and returnToAnalysisList() both clear activeJobId to orphan ongoing jobs — they save data but don't flip UI. (7) Background Job Completion Intent: User WANTS jobs to continue after HighlightDetailSheet dismisses AND after closing book - analysis saves to SwiftData when complete, available next time user opens that highlight. NO onDisappear cancellation. (8) Settings Access Pattern: Settings gear only in LibraryView. User must exit book to change settings, so config is always fresh when book opens. (9) Progress Save Defense: scenePhase monitoring + onDisappear + saveProgressSync() in deinit ensures no progress loss. (10) Scroll Reset Logic: Use `previousHighlightId != highlight.id` (not `!= nil &&`) to reset scroll when selecting ANY different highlight including from nil state. Re-tapping same highlight preserves position. (11) Database-First Deletion: Delete from DB first (can rollback), then delete files after successful save. (12) Self-Contained View Pattern: ArchivedBooksView uses LOCAL @State + withAnimation { array.removeAll } for smooth single-item removal animation. (13) Parallel Job colorHex Rule: Only the ACTIVE job (user's latest intent) may write highlight.colorHex. Background jobs must preserve current color. This is behavioral - colorHex drives analysis auto-selection on re-tap (line ~1415). Gate all background colorHex writes with `if isActiveJob`. (14) No-Cancel Polling Pattern: NEVER cancel polling Tasks in HighlightAnalysisManager or ReaderViewModel. The save guarantee MUST execute. Cancelling exits the loop → defer { clearJob } removes the job → API result lost. Use activeJobId/highlightToJobMap for UI isolation instead. (15) Cross-Context Consistency: Both HighlightAnalysisManager and ReaderViewModel operate on the same HighlightModel in SwiftData. deleteAnalysis() must reset colorHex to #FFEB3B (default yellow) when no analyses remain, in BOTH contexts. (16) View→Manager Pattern: Every user action in HighlightDetailSheet calls a single method on the manager (performAnalysis, selectAnalysis, askFollowUpQuestion, prepareForNewCustomQuestion, returnToAnalysisList). Views should NOT set manager properties individually — use methods to encapsulate state + private field changes atomically. (17) isAnalyzing Consistency: Any method that clears activeJobId should also set isAnalyzing = false, since no job is updating UI. Both returnToAnalysisList() and prepareForNewCustomQuestion() follow this rule.",
      "added_at": "2026-02-11T07:10:00.000000"
    },
    {
      "type": "convention",
      "content": "Visual & SwiftUI Patterns: (1) Card styling: color.opacity(0.15) fill + color.opacity(0.3) stroke for HighlightRow, AnalysisCard, quote blocks. (2) Chat bubbles: User right-aligned (accentColor), AI left-aligned (secondaryBackgroundColor), Comment bubble (text.bubble icon + comment color). (3) List theming: .listRowSeparator(.hidden) + .listRowBackground(theme) + .scrollContentBackground(.hidden). (4) Sheet environment: Always pass .environment(settings) to sheets. (5) sheet(item:) pattern for optional data presentation. (6) Sheet onDismiss pattern: Use .sheet(isPresented:, onDismiss: { refresh() }) to refresh parent data after modal actions (e.g., restore archived book). (7) Navigation container theming: Wrap Form in ZStack with themed background + .scrollContentBackground(.hidden) to prevent white edges when pushing views; use .toolbarBackground() + .toolbarColorScheme() for navigation bar. (8) ScrollViewReader + Transaction(disablesAnimations: true) for instant scroll reset. (9) All 5 quick analysis types + Ask Question + Comment shown in context menu. (10) Separator logic: No divider before follow-ups for bubble-style analyses (.customQuestion, .comment). (11) Theme-aware colors: Use settings.theme.textColor.opacity() instead of .foregroundStyle(.secondary) for custom themes. (12) Placeholder gradients: Use abs(hashValue) to ensure positive hue values.",
      "added_at": "2026-02-02T16:45:00.000000"
    },
    {
      "type": "future_enhancement",
      "content": "Swift Concurrency enhancements planned in docs/swift-concurrency-enhancement-plan.md: P0 (task cancellation on navigation, graceful streaming interruption), P1 (batch analysis with TaskGroup, background notifications), P2 (progress indicators, smart pre-fetching), P3 (retry logic, multi-highlight batch). Also: portable export format (.aireader) for backup/restore - currently not essential since Markdown/JSON export available. KNOWN OPTIMIZATIONS (category 2, not essential): pendingMarkerUpdatesQueue could deduplicate at insertion; chapterContext only needed for customQuestion type; job maps could be cleaned on analysis delete. Library HighlightDetailSheet has no individual analysis deletion UI (Reader's AnalysisPanelView has X button) - potential future addition.",
      "added_at": "2026-01-29T18:30:00.000000"
    }
  ],
  "manual_memories": [],
  "realtime_memories": [],
  "created_at": "2026-01-20T02:42:32.320251",
  "updated_at": "2026-02-12T09:35:00.000000"
}